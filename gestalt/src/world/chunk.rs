//! A single chunk of blocks.

use std::sync::Arc;

use vulkano::device::Device;

use crate::geometry::Mesh;
use crate::voxel::subdivstorage::{NaiveVoxelOctree, NaiveOctreeNode};
use crate::world::CHUNK_SIZE_F32;
use crate::memory::xalloc::XallocMemoryPool;


/// State used for multithreaded chunk loading. Chunk is new and being generated by world gen.
pub static CHUNK_STATE_GENERATING: usize = 0;
/// State used for multithreaded chunk loading. Chunk is dirty and needs to be meshed.
pub static CHUNK_STATE_DIRTY: usize = 1;
/// State used for multithreaded chunk loading. Chunk is currently being meshed.
pub static CHUNK_STATE_WRITING: usize = 2;
/// State used for multithreaded chunk loading. Chunk is ready to draw.
pub static CHUNK_STATE_CLEAN: usize = 3;


#[derive(Debug)]
pub struct Chunk {
    pub data: NaiveVoxelOctree<u8, ()>,
    pub position: (i32, i32, i32),
    pub dimension_id: u32,
    pub mesh: Mesh
}


impl Chunk {
    /// Constructs a new (empty) chunk.
    pub fn new(position: (i32, i32, i32), dimension_id: u32) -> Chunk {
        Chunk {
            data: NaiveVoxelOctree{scale : 6 , root: NaiveOctreeNode::new_leaf(0)},
            position,
            dimension_id,
            mesh: Mesh::new()
        }
    }

    /// Generates a mesh for the chunk, using [self::chunk_mesher].
    pub fn generate_mesh(&mut self, device: Arc<Device>, memory_pool: XallocMemoryPool) {
        crate::chunk_mesher::generate_mesh(self, device, memory_pool);
    }

    /// convert a position in chunks to a world space position for the center of that chunk
    pub fn chunk_pos_to_center_ws(chunk_pos: (i32, i32, i32)) -> (f32, f32, f32) {
        (
            (chunk_pos.0 as f32 * CHUNK_SIZE_F32) + (CHUNK_SIZE_F32 / 2.0),
            (chunk_pos.1 as f32 * CHUNK_SIZE_F32) + (CHUNK_SIZE_F32 / 2.0),
            (chunk_pos.2 as f32 * CHUNK_SIZE_F32) + (CHUNK_SIZE_F32 / 2.0)
        )
    }
}