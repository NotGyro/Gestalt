//! A single chunk of blocks.

use std::sync::Arc;

use vulkano::device::Device;

use crate::geometry::{Mesh, VertexPositionObjectId};
use crate::voxel::subdivstorage::{NaiveVoxelOctree, NaiveOctreeNode};
use crate::world::{CHUNK_SIZE_F32, CHUNK_SCALE};
use crate::memory::xalloc::XallocMemoryPool;
use crate::voxel::subdivmath::{OctPos, Scale};


/// State used for multithreaded chunk loading. Chunk is new and being generated by world gen.
pub static CHUNK_STATE_GENERATING: usize = 0;
/// State used for multithreaded chunk loading. Chunk is dirty and needs to be meshed.
pub static CHUNK_STATE_DIRTY: usize = 1;
/// State used for multithreaded chunk loading. Chunk is currently being meshed.
pub static CHUNK_STATE_MESHING: usize = 2;
/// State used for multithreaded chunk loading. Chunk is ready to draw.
pub static CHUNK_STATE_CLEAN: usize = 3;


#[derive(Debug)]
pub struct Chunk {
    pub data: NaiveVoxelOctree<u8, ()>,
    pub position: (i32, i32, i32),
    pub dimension_id: u32,
    pub mesh: Mesh,
    pub cached_occluder_verts: Option<Vec<VertexPositionObjectId>>,
    pub id: u32,
}


impl Chunk {
    /// Constructs a new (empty) chunk.
    pub fn new(id: u32, position: (i32, i32, i32), dimension_id: u32) -> Chunk {
        Chunk {
            data: NaiveVoxelOctree{scale : CHUNK_SCALE , root: NaiveOctreeNode::new_leaf(0)},
            position,
            dimension_id,
            mesh: Mesh::new(),
            cached_occluder_verts: None,
            id
        }
    }

    /// Generates a mesh for the chunk, using [self::chunk_mesher].
    pub fn generate_mesh(&mut self, device: Arc<Device>, memory_pool: XallocMemoryPool) {
        crate::chunk_mesher::generate_mesh(self, device, memory_pool);
    }

    /// convert a position in chunks to a world space position for the center of that chunk
    pub fn chunk_pos_to_center_ws(chunk_pos: (i32, i32, i32)) -> (f32, f32, f32) {
        (
            (chunk_pos.0 as f32 * CHUNK_SIZE_F32) + (CHUNK_SIZE_F32 / 2.0),
            (chunk_pos.1 as f32 * CHUNK_SIZE_F32) + (CHUNK_SIZE_F32 / 2.0),
            (chunk_pos.2 as f32 * CHUNK_SIZE_F32) + (CHUNK_SIZE_F32 / 2.0)
        )
    }

    pub fn generate_occlusion_mesh(&mut self, min_scale: Scale) {
        if self.cached_occluder_verts.is_none() {
            let mut verts = Vec::new();

            let base_x = self.position.0 as f32 * CHUNK_SIZE_F32;
            let base_y = self.position.1 as f32 * CHUNK_SIZE_F32;
            let base_z = self.position.2 as f32 * CHUNK_SIZE_F32;

            self.data.root.traverse_to_depth(opos!((0, 0, 0) @ CHUNK_SCALE), &mut |opos: OctPos<u32>, leaf: u8| {
                if leaf == 0 { return; }

                let s = (2u32.pow(opos.scale as u32)) as f32;
                let x = base_x + opos.pos.x as f32;
                let y = base_y + opos.pos.y as f32;
                let z = base_z + opos.pos.z as f32;

                verts.push(VertexPositionObjectId { position: [ x,   y,   z   ], id: self.id }); // - - -  0
                verts.push(VertexPositionObjectId { position: [ x,   y,   z+s ], id: self.id }); // - - +  1
                verts.push(VertexPositionObjectId { position: [ x,   y+s, z   ], id: self.id }); // - + -  2
                verts.push(VertexPositionObjectId { position: [ x,   y+s, z+s ], id: self.id }); // - + +  3
                verts.push(VertexPositionObjectId { position: [ x+s, y,   z   ], id: self.id }); // + - -  4
                verts.push(VertexPositionObjectId { position: [ x+s, y,   z+s ], id: self.id }); // + - +  5
                verts.push(VertexPositionObjectId { position: [ x+s, y+s, z   ], id: self.id }); // + + -  6
                verts.push(VertexPositionObjectId { position: [ x+s, y+s, z+s ], id: self.id }); // + + +  7
            }, min_scale);

            self.cached_occluder_verts = Some(verts);
        }
    }

    pub fn get_occluder_geometry(&mut self, occlusion_verts: &mut Vec<VertexPositionObjectId>, occlusion_indices: &mut Vec<u32>, offset: &mut u32) {
        if self.cached_occluder_verts.is_none() { return }

        occlusion_verts.append(&mut self.cached_occluder_verts.as_mut().unwrap().clone());
        let num_cubes = self.cached_occluder_verts.as_ref().unwrap().len() / 8;
        //println!("{}", num_cubes);
        for _ in 0..num_cubes {
            let o = *offset;
            occlusion_indices.append(&mut vec![
                o+0, o+1, o+2, o+1, o+2, o+3, // left
                o+4, o+5, o+6, o+5, o+6, o+7, // right
                o+2, o+3, o+6, o+3, o+6, o+7, // top
                o+0, o+1, o+4, o+1, o+4, o+5, // bottom
                o+0, o+2, o+4, o+2, o+4, o+6, // back
                o+1, o+3, o+5, o+3, o+5, o+7, // front
            ]);
            *offset += 8;
        }
    }
}