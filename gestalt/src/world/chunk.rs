//! A single chunk of blocks.

use phosphor::geometry::{Mesh, VertexPositionObjectId};
use phosphor::renderer::RenderInfo;

use crate::world::CHUNK_SIZE_F32;
use crate::voxel::subdivmath::Scale;
use crate::voxel::array_storage::{ArrayVoxelStorage, CHUNK_SIZE, xyz_to_index};


/// State used for multithreaded chunk loading. Chunk is new and being generated by world gen.
pub static CHUNK_STATE_GENERATING: usize = 0;
/// State used for multithreaded chunk loading. Chunk is dirty and needs to be meshed.
pub static CHUNK_STATE_DIRTY: usize = 1;
/// State used for multithreaded chunk loading. Chunk is currently being meshed.
pub static CHUNK_STATE_MESHING: usize = 2;
/// State used for multithreaded chunk loading. Chunk is ready to draw.
pub static CHUNK_STATE_CLEAN: usize = 3;


#[derive(Debug)]
pub struct Chunk {
    pub storage: ArrayVoxelStorage,
    pub position: (i32, i32, i32),
    pub dimension_id: u32,
    pub mesh: Mesh,
    pub cached_occluder_verts: Option<Vec<VertexPositionObjectId>>,
    pub id: u32,
}


impl Chunk {
    /// Constructs a new (empty) chunk.
    pub fn new(id: u32, position: (i32, i32, i32), dimension_id: u32) -> Chunk {
        Chunk {
            storage: ArrayVoxelStorage::new(),
            position,
            dimension_id,
            mesh: Mesh::new(),
            cached_occluder_verts: None,
            id
        }
    }

    /// Generates a mesh for the chunk, using [self::chunk_mesher].
    pub fn generate_mesh(&mut self, info: &RenderInfo) {
        info!(Mesher, "Generating mesh for chunk {}", self.id);
        crate::chunk_mesher::generate_mesh(self, info);
    }

    /// convert a position in chunks to a world space position for the center of that chunk
    pub fn chunk_pos_to_center_ws(chunk_pos: (i32, i32, i32)) -> (f32, f32, f32) {
        (
            (chunk_pos.0 as f32 * CHUNK_SIZE_F32) + (CHUNK_SIZE_F32 / 2.0),
            (chunk_pos.1 as f32 * CHUNK_SIZE_F32) + (CHUNK_SIZE_F32 / 2.0),
            (chunk_pos.2 as f32 * CHUNK_SIZE_F32) + (CHUNK_SIZE_F32 / 2.0)
        )
    }

    pub fn generate_occlusion_mesh(&mut self, mut min_scale: Scale) {
        if self.cached_occluder_verts.is_none() {
            let mut verts = Vec::new();

            let base_x = self.position.0 as f32 * CHUNK_SIZE_F32;
            let base_y = self.position.1 as f32 * CHUNK_SIZE_F32;
            let base_z = self.position.2 as f32 * CHUNK_SIZE_F32;

            while min_scale > 0 {
                // TODO: this is janky, should implement some kind of LOD for array chunk
                let size = 2u32.pow(min_scale as u32) as usize;
                for cx in 0..(CHUNK_SIZE / size) {
                    for cy in 0..(CHUNK_SIZE / size) {
                        for cz in 0..(CHUNK_SIZE / size) {
                            // check each chunk
                            let mut filled = true;
                            'outer: for x in (cx*size)..(cx*size+size) {
                                for y in (cy*size)..(cy*size+size) {
                                    for z in (cz*size)..(cz*size+size) {
                                        if self.storage.data[xyz_to_index(x, y, z)] == 0 {
                                            filled = false;
                                            break 'outer;
                                        }
                                    }
                                }
                            }
                            if filled {
                                let s = size as f32;
                                let x = base_x + (cx*size) as f32;
                                let y = base_y + (cy*size) as f32;
                                let z = base_z + (cz*size) as f32;

                                verts.push(VertexPositionObjectId { position: [ x,   y,   z   ], id: self.id }); // - - -  0
                                verts.push(VertexPositionObjectId { position: [ x,   y,   z+s ], id: self.id }); // - - +  1
                                verts.push(VertexPositionObjectId { position: [ x,   y+s, z   ], id: self.id }); // - + -  2
                                verts.push(VertexPositionObjectId { position: [ x,   y+s, z+s ], id: self.id }); // - + +  3
                                verts.push(VertexPositionObjectId { position: [ x+s, y,   z   ], id: self.id }); // + - -  4
                                verts.push(VertexPositionObjectId { position: [ x+s, y,   z+s ], id: self.id }); // + - +  5
                                verts.push(VertexPositionObjectId { position: [ x+s, y+s, z   ], id: self.id }); // + + -  6
                                verts.push(VertexPositionObjectId { position: [ x+s, y+s, z+s ], id: self.id }); // + + +  7
                            }
                        }
                    }
                }

                if verts.len() > 0 {
                    // geometry generated!
                    break;
                }
                else {
                    // no full voxels found at this scale, search finer
                    min_scale -= 1;
                }
            }

            self.cached_occluder_verts = Some(verts);
        }
    }

    pub fn get_occluder_geometry(&mut self, occlusion_verts: &mut Vec<VertexPositionObjectId>, occlusion_indices: &mut Vec<u32>, offset: &mut u32) {
        if self.cached_occluder_verts.is_none() { return }

        occlusion_verts.append(&mut self.cached_occluder_verts.as_mut().unwrap().clone());
        let num_cubes = self.cached_occluder_verts.as_ref().unwrap().len() / 8;
        for _ in 0..num_cubes {
            let o = *offset;
            occlusion_indices.append(&mut vec![
                o+0, o+1, o+2, o+1, o+2, o+3, // left
                o+4, o+5, o+6, o+5, o+6, o+7, // right
                o+2, o+3, o+6, o+3, o+6, o+7, // top
                o+0, o+1, o+4, o+1, o+4, o+5, // bottom
                o+0, o+2, o+4, o+2, o+4, o+6, // back
                o+1, o+3, o+5, o+3, o+5, o+7, // front
            ]);
            *offset += 8;
        }
    }
}